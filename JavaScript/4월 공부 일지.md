<h1>04/04</h1>
<h3> package.json 파일 해석</h3>

```JavaScript
{
     "description": "",
     "script":{
            "dev" : "parcel ./index.html", 
            "build": "parcel build ./index.html" 
                },
    
    "devDependencies": {
      "parcel": "^2.8.3"
        }
    }
    
```
**"dev" : "parcel ./index.html"** : 개발서버를 열어서 테스트 할때는 dev 명령어로 스크립트를 시작하고,

**"build": "parcel build ./index.html"** : 실제 제품화해서 배포할 때는 build 명령을 사용한다.<br><br> 

***
<br>
<h3>Javascript 작동 순서</h3>
!엔터치면 나오는 표준들을 모두 해석 한 후에 동작하도록 만든 다음에 body를 실행해야 하는데, 그것을 위한 코드가 script쪽에 defer 이라고 한다.<br><br>

```javascript
const string1 = "Hello"
const string2 = 'Hello'
const string3 = `Hello ${string1} ?!`
console.log(string3)

출력결과
Hello Hello ?!
```
큰 따옴표나 작은 따옴표로 문자열을 만드는 것은 취향,
그러나 햅틱을 쓰는 것은 다른 문제다.  
${string} 형식으로, 문자열 내부에 또 다른 문자열을 넣고 싶은 경우에 쓰는데, 이를 '템플릿 리터럴' 이라고 한다.<br><br>
0.1 + 0.2 = 0.3 이지만, 컴퓨터에서는 2진수 -> 10진수 변환 과정때문에 
0.30000000004 라는 오차가 발생하는데, 이를 줄이기 위한 함수가 있다.<br>
**toFixed()** : ((a+b).toFixed(몇 번째 자리까지 나타내는지 숫자))<br><br>

<h1>04/05</h1>

<h3>setTimeout() 함수를 배웠다.</h3>

```javascript
let age = null
console.log(age)

setTimeout(function () {
  age = 85
  console.log(age)
}, 1000)

츌력결과
null
85
```

setTimeout()에서 두번째 인수는 밀리초인데, 1000이 1초이다.
null찍고 1초 후에 85가 나왔다고 보면 된다.<br><br>

<h3>자바스크립트 배열 생성 문법</h3>

```javascript
// new Array 라는 문법을 보고 당황하지 말자. 
// 생성자 함수라고 불린다.
const fruits =  new Array('Apple', 'Banana', 'Cherry')
// 이번엔 배열리터럴로 생성했다 라고 불리는 방법
const fruits = ['Apple', 'Banana', 'Cherry'] 
```
***
<h3>자바스크립트에서 객체를 복사하는 방법</h3>
Object.assign() 함수이용.

```javascript
const target = { a: 1, b:2 }
const source1 ={ b:3, c:4 }
const source2 = { c:5, d: 6 }
const result = Object.assign(target, source1, source2)

console.log(target)
console.log(result)

출력결과
{a:1, b:3, c:5, d:6}
{a:1, b:3, c:5, d:6}
```
이것의 메커니즘을 보자면 이렇다. target에 source1이 덮어쓰기, 그리고 그 결과에 source2를 엎어쓰기. 따라서 target과 result의 출력이 같다.

그렇다면 target의 손상 없이 result를 만들고 싶다면?
```javascript
const target = { a: 1, b:2 }
const source1 ={ b:3, c:4 }
const source2 = { c:5, d: 6 }
const result = Object.assign({}, target, source1, source2)

console.log(target)
console.log(result)

출력결과
{a:1, b:2}
{a:1, b:3, c:5, d:6}
```
***
<h3>자바스크립트에서 객체를 2차원 배열로 만들기</h3>
Object.entries() 함수 이용.

```javascript
const user = {
  name: 'Heropy',
  age: 85,
  isValid: true,
  email 'abcd@gmail.com'
}
// 분명히 객체를 생성했다. 이걸 2차원 배열로 변환 할 수있다.
console.log(Object.entries(user))

// 2차원 배열의 요소 꺼내기
for (const [key, value of] of Object.entries(user )) {
  console.log(key, value)
}
출력결과
[Array(2), Array(2), Array(2), Array(2)]
name Heropy 등등 요소 꺼내짐. 
```

<h3>이번에는 객체의 속성의 키 값만 뽑아서 배열 만들기</h3>
Object.keys()이용.

```javascript
const user = {
  name: 'Heropy',
  age: 85,
  isValid: true,
  email 'abcd@gmail.com'
}
```  
***
<h3>함수를 console.log에 넣는 경우</h3>

```javascript
function getNumber() {
  return 123
}

console.log(getNumber)
console.log(getNumber())

출력결과 // 함수의 이름만 넣기 vs 함수 호출문 넣기
f getNumber() {
    return 123;
}

123
```
* 변수에 함수 선언을 할당하면, 그 변수의 type을 찍으면 function으로 나온다.
* typeof null은 object이다.
* []과 {} 역시 object이다. 따라서 null과 구분할 필요가 있다.
* console.log(checkType())에 넣으면 구분된다.
* console.log(!'') 빈 문자열의 부정은 true
* console.log() !{}이나 ![] 찍어보면 False 나온다.
  
<h1>04/06</h1>

<h3>Nullish 병합</h3>

```javascript
const n = 0

// OR 연산자
const num1 = 0 || 7
console.log(num1)

const num2 = 0 ?? 7
console.log(num2)
  
출력결과
7
0
```

왜 쓰는가? OR 연산자는 왼쪽 -> 오른쪽 순으로 가장 먼저 만나는 거짓이 아닌 값을 출력한다. 그런데, 0은 거짓이므로 0이 찍히지가 않는다.  
<br>
하지만 ?? 를 쓰면 왼->오는 동일하지만, null,undefined만 빼고 처음 만나는 것을 출력해 주기 때문에 0이 나올 수 있다.
***
<h3>전개 연산자</h3>

```javascript
const a = [1,2,3]

console.log(...a) // 1 2 3 점점점이 전개 연산자.
console.log(1,2,3) // 1 2 3 이렇게 출력됨.
```
왜 쓰는가? 배열 속의 요소들을 콤마 없이 꺼낼 때 (전개 할 때)

중복이 되면 어떻게 될까?

```javascript
const a = { x:1, y:2 }
const b = { y:3, z:4 }

const d = {...a, ...b}
console.log(d) // {x:1, y:3, z:4}
```
y가 중복이 되는데, 마지막으로 나온 y가 나온다. 덮어쓰기라고 하면 된다.  
<h3>가상 문제 상황 - 3인수 함수에 배열의 각 요소 넣기</h3>

```javascript
function fn(x,y,z) {
  console.log(x,y,z)
}

const a = [1,2,3] // 여기서 x=1,y=2,z=3을 넣고 싶은 상황이다.
// fn(a) 또는 fn([1,2,3]) 이건 안된다. 이것은, x에만 들어가고 y,z에는 못들어가서 undefined를 유발한다.

fn(...a) // 이렇게 하면 된다!
```
***
<h3>배열 요소 하나 하나를 변수에 따로 저장하고 싶을 때⭐⭐⭐</h3>

```javascript
// 비효율적인 방법
const arr = [1,2,3]
const a = arr[0]
const b = arr[1]
const c = arr[2]

console.log(a,b,c) // 1 2 3

// 구조 분해 할당
const [a,b,c] = arr // 배열에 배열을 넣는다? 그러면 구조 분해 할당 의심.
console.log(a,b,c) // 1 2 3

// 응용하기. 한 요소만 옮기고, 나머지는 배열 형태 유지
const arr = [1,2,3]
const [a, ...rest] = arr

console.log(a, rest) // 1 [2,3] 출력.

// 배열 말고 객체에서의 구조 분해 할당
const obj = {
  a: 1,
  b: 2,
  c: 3
}

const {a,b} = obj // 중괄호로 바꾸면 됨.
console.log(a,b) // 1 2

// 객체의 Key이름까지 바꾸면서 구조 분해 할당 해보기.
const obj = {
  a: 1,
  b: 2,
  c: 3,
  x:7
}
// 그와 동시에 갑작스런 tengen 추가 해보기.
const { x = 4, a : hero, tengen = 10} = obj
console.log(x, hero) // 4 1 10

// 구조 분해는 복사가 아니라 빼다가 옮기는 것이다.
const obj = {
  a: 1,
  b: 2,
  c: 3,
  x: 7,
  y: 100
}

const { c, ...rest} = obj
console.log(c, rest) // 3 {a:1. b:2, c:3, x:7, y:100}
// c는 rest에 없구나. 빼갔으니까.

// 함수 매개변수에 접목시켜 응용하기
const user = { 
  name: 'HEROPY',
  age: 85
}

function getName({ name }) {
  // const { name } = user 이래야 하는게 간결하게 변경 됨.
  return name
}

console.log(getName(user)) // HEROPY

```

구조 분해 할당은, 기존 배열이나 객체를 쪼개서 해산시킨다. 이 사실을 알아야 한다.
```javascript
const obj = {
    a:1,
    b:2,
    c:3,
    x:7
};

const { x=4, a: hero, tengen=10 } = obj;
console.log(b, hero, tengen); // obj에는 b가 있지만, 바로 윗줄 코드에 의해 (=구조분해할당) 해산됐다. b의 자리는 없으며, x와 a, 그리고 새로운 신입 tengen만으로 이루어진 새로운 객체가 생성 된 것이다.
```

***
<h3>없는걸 어떻게 참조해? -선택적 체이닝-</h3>

```javascript
const userA = {
  name: 'HEROPY',
  age: 85,
  address: {
    country: 'Korea',
    city: 'Seoul'
  }
}
const userB = {
  name: 'Neo',
  age: 22
}

function getCity1(user) {
  return user.address.city
}

function getCity2(user) {
  return user.address?.city
} // city 프로퍼티가 없을 수도 있는 가능성을 반영.

function getCity3(user) {
  return user.address?.city || '주소가 없습니다.'
} // city 프로퍼티가 없을 수도 있는 가능성을 반영.

console.log(getCity1(userA)) //  Seoul
console.log(getCity1(userB)) // 에러
console.log(getCity2(userB)) // .undefined
console.log(getCity3(userB)) // 주소가 없습니다.
```
***
<h3>인덱싱 없이 배열의 요소 꺼내기 - for of, for in -</h3>

```javascript
const fruits = ['Apple', 'Banana', 'Cherry']

for (const of fruits) {
  console.log(a)
}

출력결과
Apple
Banana
Cherry
```
만약 fruits가 배열이 아니라 객체이면 for (const of 가 아니라)
for (const in fruits)가 되는 것이다.
